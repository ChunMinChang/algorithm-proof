<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Algorithm Proof</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="sorting/sorting.html"><strong aria-hidden="true">1.</strong> Sorting</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="sorting/selection_sort.html"><strong aria-hidden="true">1.1.</strong> Selection sort</a></li><li class="chapter-item expanded "><a href="sorting/insertion_sort.html"><strong aria-hidden="true">1.2.</strong> Insertion sort</a></li><li class="chapter-item expanded "><a href="sorting/bubble_sort.html"><strong aria-hidden="true">1.3.</strong> Bubble sort</a></li><li class="chapter-item expanded "><a href="sorting/merge_sort.html"><strong aria-hidden="true">1.4.</strong> Merge sort</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="sorting/naive_inplace_merge.html"><strong aria-hidden="true">1.4.1.</strong> Naive in-place merge</a></li></ol></li><li class="chapter-item expanded "><a href="sorting/quick_sort.html"><strong aria-hidden="true">1.5.</strong> Quick sort</a></li><li class="chapter-item expanded "><a href="sorting/heap_sort.html"><strong aria-hidden="true">1.6.</strong> Heap sort</a></li></ol></li><li class="chapter-item expanded "><a href="graph/graph.html"><strong aria-hidden="true">2.</strong> Graph</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="graph/shortest_path.html"><strong aria-hidden="true">2.1.</strong> Shortest path</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="graph/Floyd_Warshall.html"><strong aria-hidden="true">2.1.1.</strong> Floydâ€“Warshall</a></li><li class="chapter-item expanded "><a href="graph/Dijkstra.html"><strong aria-hidden="true">2.1.2.</strong> Dijkstra</a></li><li class="chapter-item expanded "><a href="graph/Bellman_Ford_Moore.html"><strong aria-hidden="true">2.1.3.</strong> Bellman-Ford-Moore</a></li><li class="chapter-item expanded "><a href="graph/Shortest_Path_Faster_Algorithm.html"><strong aria-hidden="true">2.1.4.</strong> Shortest Path Faster Algorithm</a></li></ol></li><li class="chapter-item expanded "><a href="graph/minimal_spanning_tree.html"><strong aria-hidden="true">2.2.</strong> Minimal spanning tree</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="graph/Kruskal.html"><strong aria-hidden="true">2.2.1.</strong> Kruskal</a></li><li class="chapter-item expanded "><a href="graph/Prim.html"><strong aria-hidden="true">2.2.2.</strong> Prim</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="search/search.html"><strong aria-hidden="true">3.</strong> Search</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="search/binary_search.html"><strong aria-hidden="true">3.1.</strong> Binary search</a></li><li class="chapter-item expanded "><a href="search/interpolation_search.html"><strong aria-hidden="true">3.2.</strong> Interpolation search</a></li><li class="chapter-item expanded "><a href="search/fibonacci_search.html"><strong aria-hidden="true">3.3.</strong> Fibonacci search</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Algorithm Proof</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#sorting" id="sorting">Sorting</a></h1>
<p>To arrange items from minimal to maximal values(or maximal to minimal),
given a disorder list \( L \).</p>
<p>For examples, given \( L = [ 5, 3, 1, 2, 4, 3, 8 ] \)
and a sort function \( Sort \), the sorted list \( L_{sorted} \) is defined as:</p>
<p>\[
L_{sorted} = Sort(L)
\]</p>
<p>The results of \( L_{sorted} \) should be:
\[
L_{sorted} = [ 1, 2, 3, 3, 4, 5, 8 ]
\]
or
\[
L_{sorted} = [ 8, 5, 4, 3, 3, 2, 1 ]
\]</p>
<h1><a class="header" href="#selection-sort" id="selection-sort">Selection sort</a></h1>
<h2><a class="header" href="#idea" id="idea">Idea</a></h2>
<p>The concept is quite straight.
If we could get the minimal value from list <strong>one by one</strong>,
then we could re-arrange the list from minimal to maximal values.</p>
<p>Imagine we have two lists \(L\) and \(L_{sorted}\),
the \(L\) is a list contains several items with comparable values and
the \(L_{sorted}\) is a sorted list of \(L\).
At first, \(L_{sorted} = [ ]\) is empty.</p>
<p>Take \(L = [ 5, 3, 1, 2, 3 ]\) as an example:</p>
<ul>
<li>At the first round, we get \(1\) as minimal value,
so we move it into \(L_{sorted}\). Now,
<ul>
<li>\(L_{sorted} = [ 1 ]\)</li>
<li>\(L = [ 5, 3, 2, 3 ]\)</li>
</ul>
</li>
<li>At the second round, we get \(2\) as minimal value, so
<ul>
<li>\(L_{sorted} = [ 1, 2 ]\)</li>
<li>\(L = [ 5, 3, 3 ]\)</li>
</ul>
</li>
<li>Next, \(3\) is picked and moved from \(L\) to \(L_{sorted}\), so
<ul>
<li>\(L_{sorted} = [ 1, 2, 3 ]\)</li>
<li>\(L = [ 5, 3 ]\)</li>
</ul>
</li>
<li>Then, the current minimal value \(3\) is moved from \(L\) to \(L_{sorted}\), so
<ul>
<li>\(L_{sorted} = [ 1, 2, 3, 3 ]\)</li>
<li>\(L = [ 5 ]\)</li>
</ul>
</li>
<li>Finally, \(5\) is moved into \(L_{sorted}\), so
<ul>
<li>\(L_{sorted} = [ 1, 2, 3, 3, 5 ]\)</li>
<li>\(L = [ ]\)</li>
</ul>
</li>
</ul>
<p>See! the idea is quite simple.
In the same way, to sort the list from maximal to minimal values,
the only different is to pick the maximal value from list each round
instead of minimal value.</p>
<h3><a class="header" href="#how-to-get-minimalor-maximal-value" id="how-to-get-minimalor-maximal-value">How to get minimal(or maximal) value</a></h3>
<p>The way to get minimal(or maximal) items in \(L\)
is to linearly search the whole list:
\[
\begin{aligned}
&amp; Min(L): \newline
&amp; \space \space \space \space min = L[1] \newline
&amp; \space \space \space \space \text{for } i \leftarrow 1 \text{ to } N: \newline
&amp; \space \space \space \space \space \space \space \space \text{if } L[i] &lt; min: \newline
&amp; \space \space \space \space \space \space \space \space \space \space \space \space min = L[i]
\end{aligned}
\]
or
\[
\begin{aligned}
&amp; Max(L): \newline
&amp; \space \space \space \space max = L[1] \newline
&amp; \space \space \space \space \text{for } i \leftarrow 1 \text{ to } N: \newline
&amp; \space \space \space \space \space \space \space \space \text{if } L[i] &gt; max: \newline
&amp; \space \space \space \space \space \space \space \space \space \space \space \space max = L[i]
\end{aligned}
\]
, where \(L[i]\) is the \(i\)th element in the list \(L\)
and \(N\) is the length of \(L\).</p>
<h3><a class="header" href="#dividing-one-list-into-unsorted-list-and-sorted-list" id="dividing-one-list-into-unsorted-list-and-sorted-list">Dividing one list into unsorted list and sorted list</a></h3>
<p>In implementation, we usually divide the source list,
which needs to be sorted, into two parts. One is sorted, the other is unsorted.
This is better for memory usage than
creating another list to put the sorted results.</p>
<p>That is, if we have a source list \(L = [ 5, 3, 1, 2, 3 ]\),
it will be divided into \(L_{sorted}\) and \(L_{unsorted}\).
They are initialized to \([]\) and \(L\) respectively,
so \(L = L_{sorted} \cup L_{unsorted} = [ ] \cup [ 5, 3, 1, 2, 3 ]\).</p>
<ul>
<li>In the first round, \(1\) is picked and moved
from \(L_{unsorted}\) to \(L_{sorted}\), so
<ul>
<li>\(L = L_{sorted} \cup L_{unsorted} = [ 1 ] \cup [ 5, 3, 2, 3 ] = [1 \vert 5, 3, 2, 3]\)</li>
</ul>
</li>
<li>In the second round, \(2\) is picked and moved
from \(L_{unsorted}\) to \(L_{sorted}\), so
<ul>
<li>\(L = L_{sorted} \cup L_{unsorted} = [ 1, 2 ] \cup [ 5, 3, 3 ] = [1, 2 \vert 5, 3, 3]\)</li>
</ul>
</li>
<li>Next, \(3\) is picked, so
<ul>
<li>\(L = L_{sorted} \cup L_{unsorted} = [ 1, 2, 3 ] \cup [ 5, 3 ] = [1, 2, 3 \vert 5, 3]\)</li>
</ul>
</li>
<li>Then, another \(3\) is picked, so
<ul>
<li>\(L = L_{sorted} \cup L_{unsorted} = [ 1, 2, 3, 3 ] \cup [ 5 ] = [1, 2, 3, 3 \vert 5]\)</li>
</ul>
</li>
<li>Finally, \(5\) is picked, so
<ul>
<li>\(L = L_{sorted} \cup L_{unsorted} = [ 1, 2, 3, 3, 5 ] \cup [ ] = [1, 2, 3, 3, 5]\)</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#algorithm" id="algorithm">Algorithm</a></h2>
<p>\[
\begin{aligned}
&amp; SelectionSort(L): \newline
&amp; \space \space \space \space \text{for } i \leftarrow 1 \text{ to } \vert L \vert - 1: \newline
&amp; \space \space \space \space \space \space \space \space m \leftarrow i \newline
&amp; \space \space \space \space \space \space \space \space \text{for } j \leftarrow i + 1 \text{ to } \vert L \vert: \newline
&amp; \space \space \space \space \space \space \space \space \space \space \space \space \text{if } L[j] &lt; L[m]: \newline
&amp; \space \space \space \space \space \space \space \space \space \space \space \space \space \space \space \space m \leftarrow j \newline
&amp; \space \space \space \space \space \space \space \space \text{swap } L[i] \text{ and } L[m]
\end{aligned}
\]</p>
<p>The above method will divide \(L\) into two parts.</p>
<ul>
<li>\(L[1...i-1] = L_{sorted}\) is sorted</li>
<li>\(L[i...N] = L_{unsorted}\) is unsorted,</li>
<li>where \(N = \vert L \vert\) is the length of \(L\)</li>
</ul>
<p>The following are step by step explanation:</p>
<ul>
<li>When \(i = 1\)
<ul>
<li>\(L_{sorted} = []\) and \(L_{unsorted} = L[1...N]\)</li>
<li>we need to find the minimal element in list \(L[1...N]\)</li>
<li>We use a value \(m\) to track the <strong>index</strong> of the minimal element</li>
<li>where \(m\) is initialized to \(1\)</li>
<li>\(m\) will be updated to \(j\), where \(2 \leq j \leq N\), if \(L[j] &lt; L[m]\)</li>
<li>Repeatedly above instruction from \(j = 2\) to \(N\)(searching whole \(L_{unsorted}\)),
\(L[m]\) would be the minimal value in \(L[1...N]\)</li>
<li>swap \(L[m]\) and \(L[i = 1]\)</li>
<li>then \(L[1]\) now can be considered as \(L_{sorted}\)</li>
<li>so \(L_{unsorted} = L[2...N]\)</li>
</ul>
</li>
<li>When \(i = 2\)
<ul>
<li>\(L_{sorted} = L[1]\) and \(L_{unsorted} = L[2...N]\)</li>
<li>we need to find the minimal element in list \(L[2...N]\)</li>
<li>Same as above, \(m\) is used to keep tracking the index of the minimal
element in \(L_{unsorted}\)</li>
<li>where \(m\) is initialized to \(2\)</li>
<li>After searching the whole \(L_{unsorted}\),
\(L[m]\) would be the minimal value in \(L[2...N]\)</li>
<li>We can put \(L[m]\) into the \(L_{sorted}\) by swapping the \(L[m]\) and \(L[i = 2]\)</li>
<li>Thus, \(L_{sorted} = L[1...2]\) and \(L_{unsorted} = L[3...N]\)</li>
</ul>
</li>
<li>When \(i = k\)
<ul>
<li>\(L_{sorted} = [1...k-1]\) and \(L_{unsorted} = L[k...N]\)</li>
<li>\(m\) is initialized to \(k\)</li>
<li>After searching the whole \(L_{unsorted}\),
\(L[m]\) would be the minimal value in \(L[k...N]\)</li>
<li>Swapping \(L[m]\) and \(L[i = k]\) would put \(L[m]\) into \(L_{sorted}\)</li>
<li>Then, \(L_{sorted} = L[1...k]\) and \(L_{unsorted} = L[k+1...N]\)</li>
</ul>
</li>
<li>When \(i = N - 1\)(final round)
<ul>
<li>\(L_{sorted} = [1...N-2]\) and \(L_{unsorted} = L[N-1...N]\)</li>
<li>\(m\) is initialized to \(N-1\)</li>
<li>Pick a smaller one between \(L[N-1]\) and \(L[N]\)</li>
<li>and put it into the \(L_{sorted}\) like above(by swapping with \(L[m]\))</li>
<li>Then \(L_{sorted} = [1...N-1]\) and \(L_{unsorted} = L[N]\)</li>
<li>The left one(now is \(L[N]\)) is definitely the <strong>maximal</strong> item
in \(L[1...N]\), so we don't need to do anything</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#proof" id="proof">Proof</a></h3>
<h4><a class="header" href="#proof-by-contradiction" id="proof-by-contradiction">Proof by contradiction</a></h4>
<ul>
<li>Assume this method can <strong>not</strong> give us an ordered list</li>
<li>so it exists one \(L[p] &gt; L[q]\), where \(p &lt; q\), in the result list \(L\)</li>
<li>Before the result is computed, the unsorted list could be
\(L[..p..q..]\) or \(L[..q..p..]\)</li>
<li>It means that \(L[p]\) is picked <strong>before</strong> \(L[q]\)
because \(p &lt; q\) in the result list \(L\)</li>
<li>It means \(L[p] &lt; L[q]\) and it is contradictory to the assumption</li>
<li>Thus, the assumption is wrong. This method will give us an ordered list.</li>
</ul>
<h2><a class="header" href="#complexity" id="complexity">Complexity</a></h2>
<p>We need to search whole \(L_{unsorted}\) to find a minimal(or maximal) item.
Suppose \(\vert L_{unsorted} \vert = N\) at first.
(the length of \(L_{unsorted}\) is \(N\)).</p>
<p>At the first round, we need to search \(N\) items
to find the minimal(or maximal) item and move it into \(L_{sorted}\).
After then, \(\vert L_{unsorted} \vert = N - 1\).</p>
<p>At the second round, whole \(N - 1\) items in \(L_{unsorted}\) would be counted
to find the minimal(or maximal) one.
After the picked one is moved into \(L_{sorted}\),
the size of \(L_{unsorted}\) is reduced to \(\vert L_{unsorted} \vert = N - 2\).</p>
<p>The procedure keep working until the list \(L_{unsorted}\) is empty
(\(\vert L_{unsorted} \vert = 0\)).
Thus, we need to search
\[
\begin{aligned}
N + (N - 1) + (N - 2) + .... + 1
&amp;= \frac{ N \cdot (N + 1) }{ 2 } \newline
&amp;= \frac{ 1 }{ 2 } \cdot N^2 + \frac{ 1 }{ 2 } N
\end{aligned}
\]
times to move all the items into \(L_{sorted}\).
Thus, the complexity is \(\mathcal{O}(N^2)\),
where the \(N\) is the length of the list \(L\).</p>
<h2><a class="header" href="#implementation" id="implementation">Implementation</a></h2>
<script src="https://gist.github.com/ChunMinChang/dee9f3bd2ceab69726373ae006016edb.js?file=selection_sort.cpp"></script>
<h1><a class="header" href="#insertion-sort" id="insertion-sort">Insertion sort</a></h1>
<h2><a class="header" href="#idea-1" id="idea-1">Idea</a></h2>
<p>The basic concept is similar to <a href="sorting/selection_sort.html" title="Selection Sort"><em>Selection Sort</em></a>.
Considering there are two lists. One is already sorted,
and the other is unsorted, denoted \( L_{sorted} \) and \( L_{unsorted} \) respectively.
The key idea is to pick the element from \( L_{unsorted} \) one by one
and then <strong>insert</strong> them into the correct positions of \( L_{sorted} \).
Suppose we have \( L_{sorted} = [3, 8, 34] \)
and \( L_{unsorted} = [23, 2, 67, 34, 97] \):</p>
<ul>
<li>Step 1
<ul>
<li>Pick \( 23 \) (which is the first element) from \( L_{unsorted} \),
and insert it into \( L_{sorted} \)</li>
<li>Find a position in \( L_{sorted} \) such that
<strong>all elements before it is less than or equal to \( 23 \)
and all elements after it is greater than \( 23 \)</strong></li>
<li>Start comparing it from the <strong>last(maximal)</strong> element
to the <strong>first(minimal)</strong> one in \( L_{sorted} \)
(Or you can do same thing from the first element to the last one)</li>
<li>\( 34 \) is greater than \( 23 \), so we keep moving</li>
<li>Next, we found that \( 8 \) is less than \( 23 \)</li>
<li>A-ha! \( 23 \) should be inserted between \( 8 \) and \( 34 \)</li>
<li>The \( L_{sorted} \) and \( L_{unsorted} \) are updated to \( [3, 8, 23, 34] \)
and \( [2, 67, 34, 97] \) respectively.</li>
</ul>
</li>
<li>Step 2
<ul>
<li>Pick the current first element of \( L_{unsorted} \), \( 2 \),
and insert it into \( L_{sorted} \)</li>
<li>Same as the previous step, we start comparing \( 2 \) from the maximal element
of \( L_{sorted} \) to find the position to insert</li>
<li>\( 34 \) is obviously larger than \( 2 \), so we should keep moving</li>
<li>In this step, we can not find any element less than or equal to \( 2 \) after
the all elements in \( L_{sorted} \) are checked</li>
<li>Thus, the \( 2 \) is the minimal value among these elements</li>
<li>We should put \( 2 \) as the first element in \( L_{sorted} \)</li>
<li>The \( L_{sorted} \) and \( L_{unsorted} \) are updated to \( [2, 3, 8, 23, 34] \)
and \( [67, 34, 97] \) respectively</li>
</ul>
</li>
<li>Step 3
<ul>
<li>pick the current first element of \( L_{unsorted} \), \( 67 \),
and then insert it into \( L_{sorted} \)</li>
<li>Start comparing \( 67 \) with \( 34 \), we found \( 67 \) is greater</li>
<li>It means that \( 67 \) is the maximal value among these elements</li>
<li>Therefore, \( 67 \) should be inserted at the last position of \( L_{sorted} \)</li>
<li>The \( L_{sorted} \) and \( L_{unsorted} \) are updated to
\( [2, 3, 8, 23, 34, 67] \) and \( [34, 97] \) respectively</li>
</ul>
</li>
<li>Step 4
<ul>
<li>\( 34 \) is picked to compare with the elements in \( L_{sorted} \).</li>
<li>\( 67 \) is greater than \( 34 \), so go next</li>
<li>\( 34 \) is equal to \( 34 \), so we stop here</li>
<li>The picked \( 34 \) should be inserted between the existed \( 34 \) and \( 67 \)</li>
<li>so the \( L_{sorted} \) and \( L_{unsorted} \) are updated to
\( [2, 3, 8, 23, 34, 34, 67] \) and \( [97] \) respectively.</li>
</ul>
</li>
<li>Step 5
<ul>
<li>\( 97 \) is picked to insert.</li>
<li>\( 97 \) is greater than \( 67 \),</li>
<li>so it should be put to the last position of \( L_{sorted} \)</li>
<li>Finally, \( L_{unsorted} \) is empty
and \( L_{sorted} = [2, 3, 8, 23, 34, 34, 67, 97] \).</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#how-to-find-the-inserted-position" id="how-to-find-the-inserted-position">How to find the inserted position</a></h3>
<p>We can use the following method to find the <strong>first</strong> element
whose value is <strong>less than or equal to</strong> the picked element:
\[
\begin{aligned}
&amp; Position(L, x): \newline
&amp; \space \space \space \space i \leftarrow N \newline
&amp; \space \space \space \space \text{while } i &gt; 0 \text{ and } L[i] &gt; x: \newline
&amp; \space \space \space \space \space \space \space \space i \leftarrow i - 1 \newline
&amp; \space \space \space \space \text{return} \space i
\end{aligned}
\]
,where \( x \) is the element needs to be inserted,
\( L[i] \) is the \( i \)th element in the sorted list \( L \),
and \( N = \vert L \vert \) is the length of \( L \).</p>
<p>After getting the position \( p = Position(L, x) \) given the element \( x \),
we need to insert \( x \) between \( L[p] \) and \( L[p+1] \).
(If \( p = 0 \), then we insert \( x \) as the first element \( L[1] \).
If \( p = N \), then we insert \( x \) as the last element \( L[p + 1] \).)</p>
<h3><a class="header" href="#dividing-one-list-into-unsorted-list-and-sorted-list-1" id="dividing-one-list-into-unsorted-list-and-sorted-list-1">Dividing one list into unsorted list and sorted list</a></h3>
<p>In implementation, we usually divide the source list \( L \) into two parts.
One is sorted, the other is unsorted.
They are denoted \( L_{sorted} \) and \( L_{unsorted} \) respectively.
This is better for memory usage than
creating another list to put the sorted results.</p>
<p>Suppose we have \( L = [73, 24, 37, 9, 97, 29] = L_{sorted} \cup L_{unsorted} \),
where \( L_{sorted} \) and \( L_{unsorted} \) are initialized to \( [] \)
and \( [73, 24, 37, 9, 97, 29] \).</p>
<ul>
<li>First round
<ul>
<li>\( 73 \) is picked, but there is nothing could be compared</li>
<li>so we just put it into \( L_{sorted} \)</li>
<li>\( L_{sorted} = [73] \) and \( L_{unsorted} = [24, 37, 9, 97, 29] \)</li>
<li>now \( L = L_{sorted} \cup L_{unsorted} = [73 \vert 24, 37, 9, 97, 29] \)</li>
</ul>
</li>
<li>Second round
<ul>
<li>\( 24 \) is picked and \( p = Position(L_{sorted}, 24) = 0 \)</li>
<li>so, we should insert \( 24 \) as the <strong>first</strong> element and update lists</li>
<li>then \( L_{sorted} = [24, 73] \) and \( L_{unsorted} = [37, 9, 97, 29] \)</li>
<li>now \( L = L_{sorted} \cup L_{unsorted} = [24, 73 \vert 37, 9, 97, 29] \)</li>
</ul>
</li>
<li>Third round
<ul>
<li>\( 37 \) is picked and \( p = Position(L_{sorted}, 37) = 1 \)</li>
<li>so we should insert \( 37 \) between \( L[p] = L[1] = 24 \) and \( L[p + 1] = L[2] = 73 \)</li>
<li>then \( L_{sorted} = [24, 37, 73] \) and \( L_{unsorted} = [9, 97, 29] \)</li>
<li>now \( L = L_{sorted} \cup L_{unsorted} = [24, 37, 73 \vert 9, 97, 29] \)</li>
</ul>
</li>
<li>Fourth round
<ul>
<li>\( 9 \) is picked and \( p = Position(L_{sorted}, 9) = 0 \)</li>
<li>Thus, \( L_{sorted}, L_{unsorted} \) are updated to
\( [9, 24, 37, 73] \) and \( [97, 29] \).</li>
<li>now \( L = L_{sorted} \cup L_{unsorted} = [9, 24, 37, 73 \vert 97, 29] \)</li>
</ul>
</li>
<li>Fifth round
<ul>
<li>\( 97 \) is picked and \( p = Position(L_{sorted}, 97) = 4 = \vert L_{sorted} \vert \)</li>
<li>so we should put \( 97 \) as the <strong>last</strong> element of the \( L_{sorted} \)</li>
<li>then \( L_{sorted} = [9, 24, 37, 73, 97] \) and \( L_{unsorted} = [29] \)</li>
<li>now \( L = L_{sorted} \cup L_{unsorted} = [9, 24, 37, 73, 97 \vert 29] \).</li>
</ul>
</li>
<li>Final round
<ul>
<li>\( 29 \) is picked and \( p = Position(L_{sorted}, 29) = 2 \)</li>
<li>so we should insert \( 29 \) between \( L[p] = L[2] = 24 \) and \( L[p + 1] = L[3] = 37 \)</li>
<li>then \( L_{sorted} = [9, 24, 29, 37, 73, 97] \) and \( L_{unsorted} = [] \) is empty</li>
<li>now \( L = L_{sorted} \cup L_{unsorted} = [9, 24, 29, 37, 73, 97] \).</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#algorithm-1" id="algorithm-1">Algorithm</a></h2>
<p>\[
\begin{aligned}
&amp; InsertionSort(L): \newline
&amp; \space \space \space \space \text{for } i \leftarrow 2 \text{ to } \vert L \vert: \newline
&amp; \space \space \space \space \space \space \space \space j \leftarrow i \newline
&amp; \space \space \space \space \space \space \space \space \text{while } j &gt; 1 \text{ and } L[j-1] &gt; L[j]: \newline
&amp; \space \space \space \space \space \space \space \space \space \space \space \space \text{swap } L[j-1] \text{ and } L[j] \newline
&amp; \space \space \space \space \space \space \space \space \space \space \space \space j \leftarrow j - 1
\end{aligned}
\]</p>
<p>The above method will divide \( L \) into two parts.
\( L[1...i-1] = L_{sorted} \) is sorted, and \( L[i...N] = L_{unsorted} \) is unsorted,
where \( N = \vert L \vert \) is the length of \( L \).
The \( L[i] \) will be picked to insert into \( L_{sorted} \) iteratively.</p>
<ul>
<li>When \( i = 2 \)
<ul>
<li>\( L_{sorted} = L[1] \) and \( L_{unsorted} = L[2...N] \)</li>
<li>The goal in this round is to insert the \( L[2] \) into \( L_{sorted} \)</li>
<li>The \( L[2] \) is picked and compare with \( L[1] \)</li>
<li>If \( L[2] &lt; L[1] \), then we swap them</li>
<li>Otherwise, do nothing</li>
<li>Then, \( L_{sorted} = L[1...2] \) is sorted and \( L_{unsorted} = L[3...N] \)</li>
</ul>
</li>
<li>When \( i = 3 \)
<ul>
<li>\( L_{sorted} = L[1...2] \) and \( L_{unsorted} = L[3...N] \)</li>
<li>The goal in this round is to insert the \( L[3] \) into \( L_{sorted} \)</li>
<li>The \( L[3] \) is picked</li>
<li>If \( L[3] &gt;= L[2] \), it means that \( L[1...3] \) is sorted, so we don't need to do anything</li>
<li>Otherwise(\( L[3] &lt; L[2] \)), swap \( L[3] \) and \( L[2] \)
and check whether it needs to swap again if \( L[2] &lt; L[1] \)</li>
<li>After finishing checking, \( L_{sorted} = L[1...3] \) is sorted
and \( L_{unsorted} = L[4...N] \)</li>
</ul>
</li>
<li>When \( i = k \)
<ul>
<li>\( L_{sorted} = L[1...k-1] \) and \( L_{unsorted} = L[k...N] \)</li>
<li>The goal in this round is to insert the \( L[k] \) into \( L_{sorted} \)</li>
<li>The \( L[k] \) is picked to compare with the elements one by one in \( L_{sorted} \),
from the maximal(\( L[k-1] \)) to minimal item(\( L[1] \)), to find a place to insert</li>
<li>After finishing checking, \( L_{sorted} = L[1...k] \) is sorted
and \( L_{unsorted} \) is \( L[k+1...N] \)</li>
</ul>
</li>
<li>When \( i = N \)
<ul>
<li>\( L_{sorted} = L[1...N-1] \) and \( L_{unsorted} = L[N] \)</li>
<li>The goal in this round is to insert the \( L[N] \) into \( L_{sorted} \)</li>
<li>In the same way, the \( L[1...N] \) is sorted after finishing the procedure</li>
<li>so \( L_{sorted} \) is updated to \( L[1...N] \) and \( L_{unsorted} = [] \) is empty</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#another-method-without-swapping" id="another-method-without-swapping">Another method without swapping</a></h3>
<p>\[
\begin{aligned}
&amp; InsertionSort(L): \newline
&amp; \space \space \space \space \text{for } i \leftarrow 2 \text{ to } \vert L \vert: \newline
&amp; \space \space \space \space \space \space \space \space c \leftarrow L[i] \newline
&amp; \space \space \space \space \space \space \space \space j \leftarrow i \newline
&amp; \space \space \space \space \space \space \space \space \text{while } j &gt; 1 \text{ and } L[j-1] &gt; c: \newline
&amp; \space \space \space \space \space \space \space \space \space \space \space \space L[j] = L[j-1] \newline
&amp; \space \space \space \space \space \space \space \space \space \space \space \space j = j - 1 \newline
&amp; \space \space \space \space \space \space \space \space L[j] = c
\end{aligned}
\]</p>
<h3><a class="header" href="#proof-1" id="proof-1">Proof</a></h3>
<h4><a class="header" href="#proof-by-mathematical-induction" id="proof-by-mathematical-induction">Proof by mathematical induction</a></h4>
<blockquote>
<p>After each iteration for \( i \) in \( InsertionSort \),
the \( L[1...i] \) is sorted array.</p>
</blockquote>
<p>We need to prove this statement is true.</p>
<ul>
<li>when \( i = 2 \):
<ul>
<li>Same as the above explanation</li>
<li>The assumption is hold</li>
</ul>
</li>
<li>when \( i = k \):
<ul>
<li>Assume the statement is hold when \( i = k \)</li>
<li>\( L[1...k] \) is sorted array</li>
</ul>
</li>
<li>when \( i = k + 1 \)
<ul>
<li>If \( L[k + 1] &gt; L[k] \), then \( L[1...k + 1] \) is naturally sorted
so the proof is done</li>
<li>Otherwise, the \( L[k + 1] \) is swapped with \( L[k] \)</li>
<li>Now \( L[1...k-1] \) is sorted and \( L[k + 1] &gt; L[k] \)(after swapping!)</li>
<li>Next, we apply this algorithm to \( L = L[1...k-1] \cup L[k] \) and now \( i = k \)</li>
<li>The statement is hold when \( i = k \),
so \( L[1...k] \) is sorted after applying the algorithm</li>
<li>Now \( L[1...k] \) is sorted and \( L[k + 1] &gt; L[k] \), so the proof is done</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#complexity-1" id="complexity-1">Complexity</a></h2>
<p>The time complexity depends on the speed to find the inserted position.
The more iterations to find the value of \( Position(L, x) \) need,
the more time it takes.
The worst case is that we need to go through whole \( L_{sorted} \) to find correct
positions to insert. It happens when the list is arranged from maximal to
minimal values(e.g.,\( [5, 4, 3, 2, 1] \)).
In this case, if the length of list is \( N \), we need to search
\[
\begin{aligned}
0 + 1 + 2 + ... + (N - 1)
&amp;= \frac{ N \cdot (N - 1) }{ 2 } \newline
&amp;= \frac{ 1 }{ 2 } \cdot N^2 - \frac{ 1 }{ 2 } N
\end{aligned}
\]
times to move all the items into \( L_{sorted} \).
Thus, the complexity is \( \mathcal{O}(N^2) \).</p>
<h2><a class="header" href="#implementation-1" id="implementation-1">Implementation</a></h2>
<script src="https://gist.github.com/ChunMinChang/dee9f3bd2ceab69726373ae006016edb.js?file=insertion_sort.cpp"></script>
<h1><a class="header" href="#bubble-sort" id="bubble-sort">Bubble sort</a></h1>
<h2><a class="header" href="#idea-2" id="idea-2">Idea</a></h2>
<p>The basic concept is same to <a href="sorting/selection_sort.html" title="Selection Sort"><em>Selection Sort</em></a>.
The list is rearranged from minimal to maximal value
by picking the maximal(or minimal) value from the unsorted list iteratively.</p>
<p>In <em>selection sort</em>, the minimal element is selected after searching whole list.
On the other hand, <em>bubble sort</em> iteratively compares two neighbor elements
and swaps the elements if the left element is greater(or less) than
the right one, from the list head to the list tail.
Therefore, the maximal, the second-maximal, ... values will be
&quot;bubbled&quot; up to the tail of list one by one.</p>
<p>Take L = \([ 5, 3, 4, 2, 1 ]\) as an example:</p>
<ul>
<li>Step 1: Move the <strong>maximal</strong> value to the <strong>last</strong> position of the list.
<ul>
<li>\(5 &gt; 3\) so swap them. \(L = [ 3, 5, 4, 2, 1 ]\)</li>
<li>\(5 &gt; 4\) so swap them. \(L = [ 3, 4, 5, 2, 1 ]\)</li>
<li>\(5 &gt; 2\) so swap them. \(L = [ 3, 4, 2, 5, 1 ]\)</li>
<li>\(5 &gt; 1\) so swap them. \(L = [ 3, 4, 2, 1, 5 ]\)</li>
<li>The maximal value \(5\) is moved to the last of the list</li>
</ul>
</li>
<li>Step 2: Move the <strong>second-maximal</strong> value to the <strong>second-last</strong> position of the list.
<ul>
<li>\(3 &lt; 4\) so do nothing.</li>
<li>\(4 &gt; 2\) so swap them. \(L = [ 3, 2, 4, 1, 5 ]\)</li>
<li>\(4 &gt; 1\) so swap them. \(L = [ 3, 2, 1, 4, 5 ]\)</li>
<li>The second-maximal value \(4\) is moved to the second-last of the list</li>
</ul>
</li>
<li>Step 3: Move the <strong>third-maximal</strong> value to the <strong>third-last</strong> position of the list.
<ul>
<li>\(3 &gt; 2\) so swap them. \(L = [ 2, 3, 1, 4, 5 ]\)</li>
<li>\(3 &gt; 1\) so swap them. \(L = [ 2, 1, 3, 4, 5 ]\)</li>
<li>The third-maximal value \(3\) is moved to the third-last of the list</li>
</ul>
</li>
<li>Step 4: Move the <strong>fourth-maximal</strong> value to the <strong>fourth-last</strong> position of the list.
<ul>
<li>\(2 &gt; 1\) so swap them. \(L = [ 1, 2, 3, 4, 5 ]\)</li>
<li>The fourth-maximal value \(2\) is moved to the fourth-last of the list</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#dividing-one-list-into-unsorted-list-and-sorted-list-2" id="dividing-one-list-into-unsorted-list-and-sorted-list-2">Dividing one list into unsorted list and sorted list</a></h3>
<p>In above example, the list is naturally partition into the sorted part
and the unsorted part.
The part contains the &quot;bubbled&quot; elements are sorted.
The others are unsorted.</p>
<ul>
<li>Step 1: Move the <strong>maximal</strong> value to the <strong>last</strong> position of the list.
<ul>
<li>This iteration ends after the comparison of last two elements(<em>4th</em> and <em>5th</em>)</li>
<li>The maximal value \(5\) is &quot;bubbled&quot; to the last(<em>5th</em>) of the list</li>
<li>\(L = [ 3, 2, 4, 1, | 5 ]\)</li>
<li>The <em>5th</em> element is sorted part and the <em>1st-to-4th</em> is unsorted part</li>
</ul>
</li>
<li>Step 2: Move the <strong>second-maximal</strong> value to the <strong>second-last</strong> position of the list.
<ul>
<li>This iteration ends after the comparison of second-last two elements(<em>3rd</em> and <em>4th</em>)</li>
<li>The second-maximal value \(4\) is &quot;bubbled&quot; to the second-last(<em>4th</em>) of the list</li>
<li>\(L = [ 3, 2, 1, | 4, 5 ]\)</li>
<li>The <em>4th-to-5th</em> elements is sorted part and the <em>1st-to-3rd</em> is unsorted part</li>
</ul>
</li>
<li>Step 3: Move the <strong>third-maximal</strong> value to the <strong>third-last</strong> position of the list.
<ul>
<li>This iteration ends after the comparison of third-last two elements(<em>2nd</em> and <em>3rd</em>)</li>
<li>The third-maximal value \(3\) is &quot;bubbled&quot; to the third-last(<em>3rd</em>) of the list</li>
<li>\(L = [ 2, 1, | 3, 4, 5 ]\)</li>
<li>The <em>3rd-to-5th</em> elements is sorted part and the <em>1st-to-2nd</em> is unsorted part</li>
</ul>
</li>
<li>Step 4: Move the <strong>fourth-maximal</strong> value to the <strong>fourth-last</strong> position of the list.
<ul>
<li>This iteration ends after the comparison of fourth-last two elements(<em>1st</em> and <em>2nd</em>)</li>
<li>The fourth-maximal value \(2\) is &quot;bubbled&quot; to the fourth-last(<em>2nd</em>) of the list</li>
<li>\(L = [ 1, | 2, 3, 4, 5 ]\)</li>
<li>The <em>2nd-to-5th</em> elements is sorted part and the <em>1st</em> is unsorted part</li>
<li>The last left element is definitely the <strong>smallest</strong> value</li>
<li>so whole list from <em>1st</em> to <em>5th</em> is sorted</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#algorithm-2" id="algorithm-2">Algorithm</a></h2>
<p>\[ \begin{aligned}
&amp; BubbleSort(L): \newline
&amp; \space \space \space \space \text{for } i \leftarrow 1 \text{ to } \vert L \vert - 1: \newline
&amp; \space \space \space \space \space \space \space \space \text{for } j \leftarrow 1 \text{ to } \vert L \vert - i: \newline
&amp; \space \space \space \space \space \space \space \space \space \space \space \space \text{if } L[j] &gt; L[j+1]: \newline
&amp; \space \space \space \space \space \space \space \space \space \space \space \space \space \space \space \space \text{swap } L[j] \text{ and } L[j+1] \newline
\end{aligned} \]</p>
<ul>
<li>At the 1st round, the 1st-last element is sorted</li>
<li>At the 2nd round, the 2nd-last to 1st-last elements are sorted</li>
<li>At the 3rd round, the 3rd-last to 1st-last elements are sorted</li>
<li>At the \(k\) round, the \(k\)-last to 1st-last elements are sorted</li>
</ul>
<h3><a class="header" href="#proof-2" id="proof-2">Proof</a></h3>
<h4><a class="header" href="#proof-by-mathematical-induction-1" id="proof-by-mathematical-induction-1">Proof by mathematical induction</a></h4>
<h5><a class="header" href="#lemma-1" id="lemma-1">Lemma 1</a></h5>
<p>\[
\begin{aligned}
&amp; \text{for } j \leftarrow 1 \text{ to } \vert L \vert - 1: \newline
&amp; \space \space \space \space \text{if } L[j] &gt; L[j+1]: \newline
&amp; \space \space \space \space \space \space \space \space \text{swap } L[j] \text{ and } L[j+1] \newline
\end{aligned}
\]</p>
<blockquote>
<p>Given a list \(L\) with \(N\) elements, where \(N = \vert L \vert &gt; 0\),
the maximal element of \(L\) will be \(L[N]\)(the last element).</p>
</blockquote>
<ul>
<li>Base step: When \(N = 1\), the assumption obviously holds</li>
<li>Induction Hypothesis: Assume the hypothesis holds when \(N = k(j \leftarrow 1 \text{ to } k-1)\)</li>
<li>Induction Step: when \(N = k + 1\)
<ul>
<li>After the iteration of \(j = k - 1\),
the list is divided into two parts: \(L[1...k]\) and \(L[k+1]\)</li>
<li>From above hypothesis, the maximal value in \(L[1...k]\) is \(L[k]\)</li>
<li>When \(j = k\):
<ul>
<li>if \(L[k] \leq L[k+1]\), then the maximal element is \(L[k+1]\),
so the hypothesis still holds</li>
<li>if \(L[k] &gt; L[k+1]\), they will be swapped.
After then, the maximal element will be \(L[k+1]\),
so the hypothesis still holds</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5><a class="header" href="#lemma-2" id="lemma-2">Lemma 2</a></h5>
<p>\[
\begin{aligned}
&amp; \text{for } i \leftarrow 1 \text{ to } \vert L \vert - 1: \newline
&amp; \space \space \space \space \text{for } j \leftarrow 1 \text{ to } \vert L \vert - i: \newline
&amp; \space \space \space \space \space \space \space \space \text{if } L[j] &gt; L[j+1]: \newline
&amp; \space \space \space \space \space \space \space \space \space \space \space \space \text{swap } L[j] and L[j+1] \newline
\end{aligned}
\]</p>
<blockquote>
<p>After the \(i\) iteration,
\(L[N - i + 1]\) will be the \(i\)th largest element of \(L[1...N]\)</p>
</blockquote>
<ul>
<li>Base step: When \(i = 1\), the assumption holds because <em>lemma 1</em> is true</li>
<li>Induction Hypothesis: Assume hypothesis holds when \(i = k\)</li>
<li>Induction Step: When \(i = k + 1\)
<ul>
<li>The goal is to prove that the \(L[N - k]\) is
the \((k + 1)\)th largest element of \(L[1...N]\)</li>
<li>After the iteration \(i = k\), \(L[N-k+1]\) is the \(k\)th
largest element of \(L[1...N]\)</li>
<li>We can divide the list into \(L[1...N-k]\) and \(L[N-k+1...N]\)
<ul>
<li>The list \(L[N-k+1...N]\) contains the picked
\(k\)th, \((k-1)\)th, .... , \(1\)st largest elements</li>
<li>The list \(L[1...N-k]\) is the unselected and unsorted list</li>
</ul>
</li>
<li>By applying the <em>lemma 1</em> to \(L[1...N-k]\),
the maximal element of \(L[1...N-k]\) will be \(L[N-k]\)
after all the iterations for \(1 \leq j \leq N - k\).</li>
<li>\(L[N-k]\) is the \((k+1)\)th selected maximal element</li>
<li>so \(L[N - (k+1) + 1] = L[N-k]\) is the \((k+1)\)th largest element of \(L[1...N]\)</li>
</ul>
</li>
</ul>
<h5><a class="header" href="#conclusion" id="conclusion">Conclusion</a></h5>
<p>By <em>lemma 2</em></p>
<ul>
<li>After \(i = 1\), \(L[N]\) is the \(1\)st largest element of \(L[1...N]\)</li>
<li>After \(i = 2\), \(L[N - 1]\) is the \(2\)nd largest element of \(L[1...N]\)</li>
<li>After \(i = 3\), \(L[N - 2]\) is the \(3\)rd largest element of \(L[1...N]\)</li>
<li>...</li>
<li>After \(i = k\), \(L[N - k + 1]\) is the \(k\)th largest element of \(L[1...N]\)</li>
<li>After \(i = k+1\), \(L[N - k]\) is the \((k+1)\)th largest element of \(L[1...N]\)</li>
<li>...</li>
<li>After \(i = N-2\), \(L[3]\) is the \(N-2\)th largest element of \(L[1...N]\)</li>
<li>After \(i = N-1\), \(L[2]\) is the \(N-1\)th largest element of \(L[1...N]\)</li>
<li>After \(i = N\), \(L[1]\) is the \(N\)th largest element of \(L[1...N]\)</li>
</ul>
<p>Thus, the list $L[1...N]$ is sorted by the order that \(L[1] \leq L[2] \leq L[3] \leq ... \leq L[N-1] \leq L[N]\).</p>
<h2><a class="header" href="#complexity-2" id="complexity-2">Complexity</a></h2>
<p>Let \(N = \vert L \vert\) denote the length of list \(L\).</p>
<table><thead><tr><th>\(i\)</th><th>iterations for \(j\)</th></tr></thead><tbody>
<tr><td>\(1\)</td><td>\(j \in [1, N-1]\)</td></tr>
<tr><td>\(2\)</td><td>\(j \in [1, N-2]\)</td></tr>
<tr><td>...</td><td>...</td></tr>
<tr><td>\(N-2\)</td><td>\(j \in [1, 2]\)</td></tr>
<tr><td>\(N-1\)</td><td>\(j = 1\)</td></tr>
</tbody></table>
<p>The total of all iterations of <em>BubbleSort(\(L\))</em> is tracked in above table
and its sum is:</p>
<p>\[
\begin{aligned}
(N - 1) + (N - 2) + ... + 2 + 1
&amp;= \frac{ N \cdot (N - 1) }{ 2 } \newline
&amp;= \frac{ 1 }{ 2 } \cdot N^2 - \frac{ 1 }{ 2 } N
\end{aligned}
\]</p>
<p>Thus, the complexity is \(\mathcal{O}(N^2)\).</p>
<h2><a class="header" href="#implementation-2" id="implementation-2">Implementation</a></h2>
<script src="https://gist.github.com/ChunMinChang/dee9f3bd2ceab69726373ae006016edb.js?file=bubble_sort.cpp"></script>
<h1><a class="header" href="#merge-sort" id="merge-sort">Merge sort</a></h1>
<h2><a class="header" href="#idea-3" id="idea-3">Idea</a></h2>
<p><em>Merge sort</em> is an efficient algorithm that
applies the concepts of <a href="https://en.wikipedia.org/wiki/Divide_and_conquer_algorithm" title="Divide and conquer algorithm"><em>divide and conquer</em></a> to sort the list.</p>
<p>The key idea of <a href="https://en.wikipedia.org/wiki/Divide_and_conquer_algorithm" title="Divide and conquer algorithm"><em>divide and conquer</em></a> is to recursively break down the problems
into two or more sub-problems and they are same or related to the original problem,
until these divided sub-problems are simple enough to solve directly.
Then, the solutions of the original problem can be combined and derived
by the solutions of all the sub-problems.</p>
<h3><a class="header" href="#divide-and-conquer" id="divide-and-conquer">Divide and conquer</a></h3>
<p>The calculation of <a href="https://en.wikipedia.org/wiki/Fibonacci_number" title="Fibonacci number"><em>Fibonacci number</em></a>, \( F(n) = F(n-1) + F(n-2) \),
is one example.
To calculate \( F(n) \), it needs to find \( F(n-1) \) and \( F(n-2) \).
Similarly, to calculate \( F(n-1) \), it needs to \( F(n-2) \) and \( F(n-3) \).
The sub-problems for calculating \( F(n-1) \) and \( F(n-2) \) have same form
as the one for \( F(n) \).</p>
<p>Recursively, we will need to get \( F(n-1) \), \( F(n-2) \), ..., \( F(2) \), \( F(1) \)
and \( F(1) \) and \( F(2) \) are easy enough to solve directly. They are both \( 1 \).
Thus, \( F(3) = F(2) + F(1) = 2 \), \( F(4) = F(3) + F(2) = 3 \), ... and then \( F(n) \)
can be computed.</p>
<h3><a class="header" href="#dividing-the-sorting-problem" id="dividing-the-sorting-problem">Dividing the sorting-problem</a></h3>
<p>Let's apply this concept to the sorting problem.
If we want to sort the list \( L = [6, 3, 7, 1, 9, 2, 5] \),
the sub-lists \( [6, 3, 7, 1], [9, 2, 5] \) must also be sorted,
so we can narrow down our problem scope for handling the sub-lists.
Next, \( [6, 3, 7, 1] \) can be divided to \( [6, 3], [7, 1] \)
and \( [6, 3] \) also can be split into \( [6] \) and \( [3] \).
Finally, \( [6], [3] \) are not dividable
so we stop breaking down the list.</p>
<pre>
       [6, 3, 7, 1, 9, 2, 5]
         /               \
   [6, 3, 7, 1]       [9, 2, 5]
    /        \          /     \
 [6, 3]    [7, 1]    [9, 2]  [5]
 /    \    /    \    /    \
[6]  [3]  [7]  [1]  [9]  [2]
</pre>
<p>In the same way, the whole list can be divided into
\( [6], [3], [7], [1], [9], [2], [5] \).</p>
<h3><a class="header" href="#conquering-the-sub-problems" id="conquering-the-sub-problems">Conquering the sub-problems</a></h3>
<p>After there is only one element left,
the subproblem is solved by nature since it's already sorted.</p>
<p>However, the problem becomes</p>
<blockquote>
<p>how do we combine these sorted chunks into a sorted list</p>
</blockquote>
<p>We need a method that can merge two sorted lists,
\( L_1[1...X] \) and \( L_2[1...Y] \), where \( X, Y \geq 1 \),
into a bigger sorted list \( L[1...(X+Y)] \).</p>
<h3><a class="header" href="#combining-all-the-results-of-sub-sorting-problem" id="combining-all-the-results-of-sub-sorting-problem">Combining all the results of sub-sorting-problem</a></h3>
<p>Suppose we have two sorted lists \( A = [3, 6, 10, 23] \) and \( B = [2, 7, 50, 55] \).
We provide two ways to merge them into a sorted list.</p>
<h4><a class="header" href="#picking-the-smallest-elements-one-by-one" id="picking-the-smallest-elements-one-by-one">Picking the smallest elements one by one</a></h4>
<p>The simplest method is to pick the smallest elements iteratively
by searching both lists from the minimal to maximal.</p>
<p>We only need to compare the left most elements of both lists
and pick the smaller one since \( A \) and \( B \) are already sorted.</p>
<p>The following example demonstrate the process of this idea:</p>
<pre>
() <- search index

A = [(3), 6, 10, 23]
B = [(2), 7, 50, 55]
L = []                            // <- 2
</pre>
<p>In the first round, \( 2 \) is picked since \( 2 &lt; 3 \)
and going to be put into another list \( L \).</p>
<pre>
                                  // You can think the left most element
                                  // is shifted one by one
A = [(3), 6, 10, 23]              // [3, 6, 10, 23]
B = [2, (7), 50, 55]              // [7, 50, 55]
L = [2]                           // <- 3
</pre>
<p>After \( 2 \) is picked, we move the index of \( B \) from \( 2 \) to \( 7 \).
Next, \( 3 \) is picked since \( 3 &lt; 7 \) and going to be put into \( L \).</p>
<pre>
A = [3, (6), 10, 23]              // [6, 10, 23]
B = [2, (7), 50, 55]              // [7, 50, 55]
L = [2, 3]                        // <- 6
</pre>
<p>After \( 3 \) is picked, we move the index of \( A \) from \( 3 \) to \( 6 \).
Next, \( 6 \) is picked since \( 6 &lt; 7 \) and going to be put into \( L \).</p>
<pre>
A = [3, 6, (10), 23]              // [10, 23]
B = [2, (7), 50, 55]              // [7, 50, 55]
L = [2, 3, 6]                     // <- 7
</pre>
<p>After \( 6 \) is picked, we move the index of \( A \) from \( 6 \) to \( 10 \).
Next, \( 7 \) is picked since \( 7 &lt; 10 \) and going to be put into \( L \).</p>
<pre>
A = [3, 6, (10), 23]              // [10, 23]
B = [2, 7, (50), 55]              // [50, 55]
L = [2, 3, 6, 7]                  // <- 10
</pre>
<p>After \( 7 \) is picked, we move the index of \( B \) from \( 7 \) to \( 50 \).
Next, \( 10 \) is picked since \( 10 &lt; 50 \) and going to be put into \( L \).</p>
<pre>
A = [3, 6, 10, (23)]              // [23]
B = [2, 7, (50), 55]              // [50, 55]
L = [2, 3, 6, 7, 10]
</pre>
<p>After \( 10 \) is picked, we move the index of \( A \) from \( 10 \) to \( 23 \).
Next, \( 23 \) is picked since \( 23 &lt; 50 \) and going to be put into \( L \).</p>
<pre>
A = [3, 6, 10, 23]                // []
B = [2, 7, (50), 55]              // [50, 55]
L = [2, 3, 6, 7, 10, 23]
</pre>
<p>After \( 23 \) is picked, there is no need to compare again
since the \( 23 \) is the last element in \( A \).</p>
<pre>
A = [3, 6, 10, 23]                // []
B = [2, 7, 50, 55]                // []
L = [2, 3, 6, 7, 10, 23, 50, 55]
</pre>
<p>Next, we can append all the rest elements
from \( 50 \) to the end of \( B \) into the \( L \).
Finally, we get a sort list \( L \).</p>
<h4><a class="header" href="#swapping-the-elements-one-by-one" id="swapping-the-elements-one-by-one">Swapping the elements one by one</a></h4>
<p>Another idea to merge the two sorted lists
\( A = [3, 6, 10, 23] \) and \( B = [2, 7, 50, 55] \),
is to couple them together into a list \( L = A \cup B \)</p>
<pre>
() <- element who will be moved
L = [3, 6, 10, 23, | (2), 7, 50, 55]

// The '|' doesn't exist! It's only a notation for better explanation.
</pre>
<p>and then move the minimal element of the later list(\( B \))
to the right position of the former list(\( A \)).</p>
<p>The way for finding right the position is to compare the elements one by one
from the end of the former list(\( A \)) to its head.</p>
<pre>
() <- element who will be moved
L = [3, 6, 10, (2), 23, | 7, 50, 55]
</pre>
<p>In our example, the \( 2 \) is swapped with \( 23 \) since \( 2 &lt; 23 \).
Then we keep comparing \( 2 \) with \( 10 \).</p>
<pre>
() <- element who will be moved
L = [3, 6, (2), 10, 23, | 7, 50, 55]
</pre>
<p>Similarly, the \( 2, 10 \) are swapped since \( 2 &lt; 10 \).</p>
<pre>
() <- element who will be moved
L = [3, (2), 6,  10, 23, | 7, 50, 55]
</pre>
<p>Next, the \( 2, 6 \) are swapped since \( 2 &lt; 6 \).</p>
<pre>
() <- element who will be moved
L = [(2), 3, 6,  10, 23, | 7, 50, 55]
</pre>
<p>Next, the \( 2, 3 \) are swapped since \( 2 &lt; 3 \).
After this round, there is nothing to compare,
so the \( 2 \) is moved to its right position.
Now \( A = [2, 3, 6, 10, 23] \) and \( B = [7, 50, 55] \)</p>
<p>In the same way, we can do this process again with \( 7 \).
It's the minimal element of the later list \( B \) now.</p>
<pre>
() <- element who will be moved
L = [2, 3, 6, 10, 23, | (7), 50, 55]
L = [2, 3, 6, 10, (7), 23, | 50, 55]
L = [2, 3, 6, (7), 10, 23, | 50, 55]

L = [2, 3, 6, 7, 10, 23, | 50, 55]
</pre>
<p>After this round, \( A = [2, 3, 6, 7, 10, 23] \) and \( B = [50, 55] \).</p>
<p>Then do it again with with \( 50 \).</p>
<pre>
() <- element who will be moved
L = [2, 3, 6,  7, 10, 23, | (50), 55]

L = [2, 3, 6,  7, 10, 23, 50, | 55]
</pre>
<p>However, \( 50 \) doesn't move because \( 23 &lt; 50 \).
We just need to append \( 50 \) to the end of the former list \( A \).
After this round, \( A = [2, 3, 6, 7, 10, 23, 50] \) and \( B = [55] \).</p>
<pre>
() <- element who will be moved
L = [2, 3, 6,  7, 10, 23, 50, | (55)]

L = [2, 3, 6,  7, 10, 23, 50, 55]
</pre>
<p>It's same to \( 55 \).
It doesn't need to be moved since \( 50 &lt; 55 \),
so just append it to the \( A \).
Finally, \( A = [2, 3, 6, 7, 10, 23, 50, 55] \) and \( B = [] \) is empty now.
Now we have a sorted list \( L = A \cup B = A \)!</p>
<h4><a class="header" href="#which-merge-method-is-better" id="which-merge-method-is-better">Which merge method is better</a></h4>
<p>The first method use <strong>extra space</strong> to store the sorted results,
rather than the second in-place solution.
On the other hand, the second method needs <strong>more swapping executions</strong>
and its a linear operation.
For better performance, we take the first method as our approach here.</p>
<p>Actually, there is a way to save the extra space
and it works as fast as the first method above.
However, it's complicated.
I will write another post for illustrating it.
Please refer <em>In-place merge sort</em> in <a href="https://github.com/liuxinyu95/AlgoXY/releases/download/v0.618033/elementary-algorithms.pdf" title="Elementary Algorithms">Elementary Algorithms</a>
to read it.</p>
<h2><a class="header" href="#algorithm-3" id="algorithm-3">Algorithm</a></h2>
<p>\[
\begin{aligned}
&amp; MergeSort(L): \newline
&amp; \space \space \space \space mergeSort(L, 1, \vert L \vert)
\end{aligned}
\]</p>
<p>\[
\begin{aligned}
&amp; mergeSort(L, l, r): \newline
&amp; \space \space \space \space \text{if } l &lt; r: \newline
&amp; \space \space \space \space \space \space \space \space m \leftarrow \lfloor \frac{l+r}{2} \rfloor \newline
&amp; \space \space \space \space \space \space \space \space mergeSort(L, l, m) \newline
&amp; \space \space \space \space \space \space \space \space mergeSort(L, m+1, r) \newline
&amp; \space \space \space \space \space \space \space \space merge(L, l, m, r)
\end{aligned}
\]</p>
<p>\[
\begin{aligned}
&amp; merge(L, l, m, r): \newline
&amp; \space \space \space \space L^\prime \leftarrow [] \newline
&amp; \space \space \space \space i \leftarrow l, j \leftarrow m+1, k \leftarrow l \newline
&amp; \space \space \space \space \text{while } i \leq m \text{ and } j \leq r: \newline
&amp; \space \space \space \space \space \space \space \space \text{if } L[i] &lt; L[j]: \newline
&amp; \space \space \space \space \space \space \space \space \space \space \space \space L^\prime[k] \leftarrow L[i] \newline
&amp; \space \space \space \space \space \space \space \space \space \space \space \space i \leftarrow i + 1 \newline
&amp; \space \space \space \space \space \space \space \space \text{else}: \newline
&amp; \space \space \space \space \space \space \space \space \space \space \space \space L^\prime[k] \leftarrow L[j] \newline
&amp; \space \space \space \space \space \space \space \space \space \space \space \space j \leftarrow j + 1 \newline
&amp; \space \space \space \space \space \space \space \space k \leftarrow k + 1 \newline
&amp; \space \space \space \space \text{while } i \leq m: \newline
&amp; \space \space \space \space \space \space \space \space L^\prime[k] \leftarrow L[i] \newline
&amp; \space \space \space \space \space \space \space \space i \leftarrow i + 1 \newline
&amp; \space \space \space \space \space \space \space \space k \leftarrow k + 1 \newline
&amp; \space \space \space \space \text{while } j \leq r: \newline
&amp; \space \space \space \space \space \space \space \space L^\prime[k] \leftarrow L[j] \newline
&amp; \space \space \space \space \space \space \space \space j \leftarrow j + 1 \newline
&amp; \space \space \space \space \space \space \space \space k \leftarrow k + 1 \newline
&amp; \space \space \space \space \text{for } i \leftarrow l \text{ to } r: \newline
&amp; \space \space \space \space \space \space \space \space L[i] \leftarrow L^\prime[i]
\end{aligned}
\]</p>
<h3><a class="header" href="#proof-3" id="proof-3">Proof</a></h3>
<h4><a class="header" href="#correctness-of-merge" id="correctness-of-merge">Correctness of <em>Merge</em></a></h4>
<pre>
  List L

        <------   sorted   ------> <------   sorted  ------->
        <- merged -> <---  A  ---> <- merged -> <---  B  --->
  -----+---+--------+---+-----+---+-----+------+---+-----+---+-----
   ... | l | ...... | i | ... | m | m+1 | .... | j | ... | r | ...
  -----+---+--------+---+-----+---+-----+------+---+-----+---+-----
                      ^                          ^
                head of sublist A          head of sublist B

  List L'

   <--   merged  --> <---   empty   --->
  +---+-------+-----+---+-------+-------+
  | 1 |  ...  | k-1 | k | ..... | r-l+1 |
  +---+-------+-----+---+-------+-------+
                      ^
                head of empty area of list L'

  L[l...m]    : the sorted sublists for merging with L[m+1...r]
  L[m+1...r]  : the sorted sublists for merging with L[l...m]
  A, B        : the sublists containing elements that have NOT been merged yet
  L'[1...k-1] : the merged list from L[l...i-1] and L[m+1...j-1]

  i: The index of the first element in L[l...m] that has NOT been merged yet
  j: The index of the first element in L[m+1...r] that has NOT been merged yet
  k: The index of next merged element copied from L[i] or L[j]
</pre>
<p><strong>Loop Invariant</strong>:
At the beginning of the while-loop, the following conditions hold:</p>
<ol>
<li>Sublists \( L[i...m] \) and \( L[j...r] \) are sorted</li>
<li>\( L^\prime \) holds the elements from sublists \( L[l...i-1] \) and \( L[m+1...j-1] \)</li>
<li>All elements in \( L^\prime[1...k-1] \) is less or equal than
sublists \( L[i...m] \) and \( L[j...r] \)</li>
<li>\( L^\prime \) are sorted.
Formally, \( \forall i \in [l + 1, r], L^\prime[i - 1] \leq L^\prime[i] \)</li>
</ol>
<p>Then we use loop-invariants to prove:</p>
<ul>
<li>Initialization: At the very beginning when \( k = 1, i = l, j = m+1 \)
<ul>
<li>the input \( L[l...m], L[m+1...r] \) are sorted so <em>1</em> holds</li>
<li>the list \( L^\prime \) is empty so <em>2, 3, 4</em> hold</li>
</ul>
</li>
<li>Maintenance: Consider the iteration \( k = x \)
<ul>
<li><em>1</em> is preserved since there is no change in \( L \)</li>
<li><em>2</em> is preserved because
<ul>
<li>If \( j &gt; r \lor (i \leq m \land L[i] &lt; L[j]) \), \( L^\prime[k] \leftarrow L[i] \)
<ul>
<li>then \( k \leftarrow k+1, i \leftarrow i+1 \)</li>
<li><em>3</em> is preserved because \( L[k-1] = L[i-1] &lt; L[j] \leq L[j+1] \leq ... \leq L[r] \)
and \( L[k-1] = L[i-1] \leq L[i] \leq ... \leq L[m] \)</li>
</ul>
</li>
<li>Otherwise, \( L^\prime[k] \leftarrow L[j] \)
<ul>
<li>then \( k \leftarrow k+1, j \leftarrow j+1 \)</li>
<li><em>3</em> is preserved because \( L[k-1] = L[j-1] &lt; L[j] \leq L[j+1] \leq ... \leq L[r] \)
and \( L[k-1] = L[j-1] \leq L[i] \leq L[i+1] \leq ... \leq L[m] \)</li>
</ul>
</li>
</ul>
</li>
<li>The previous appended element must be smaller than
the current selected minimal element or <em>1</em> is false</li>
<li>By <em>3</em>, the next selected minimal element will be larger than current one</li>
<li>So <em>4</em> is also preserved</li>
</ul>
</li>
<li>Termination
<ul>
<li>By <strong>2</strong>, \( L^\prime \) consists of the elements in \( L[l...r] \)</li>
<li>By <strong>4</strong>, \( L[l...r] = L^\prime[l...r] \) are sorted</li>
</ul>
</li>
</ul>
<h4><a class="header" href="#correctness-of-merge-sort" id="correctness-of-merge-sort">Correctness of <em>Merge Sort</em></a></h4>
<blockquote>
<p>Given a list \( L \) with \( N \) elements,
the \( L \) can be sorted
by applying the above the <em>MergeSort</em> with \( l = 1, r = N \).</p>
</blockquote>
<ul>
<li>Base step: When \( N = 1 \), it's trivial.</li>
<li>Induction Hypothesis:
Suppose this assumption holds when list has \( N = 1, 2, ..., k \) elements</li>
<li>Induction Step: When \( N = k + 1 \)
<ul>
<li>the list \( L \) is divide to \( L[1...m] \)(\( m \) elements)
and \( L[m+1...N] \)(\( N - m \) elements)</li>
<li>so \( m = \lfloor \frac{1+(k+1)}{2} \rfloor = \lfloor \frac{k}{2} \rfloor + 1 \leq k \)</li>
<li>\( 1 \leq m \to 0 \leq m-1  \)
<ul>
<li>\(  \to k \leq k-1+m  \)</li>
<li>\(  \to k+1 \leq k+m  \)</li>
<li>\(  \to (k+1)-m \leq k  \)</li>
<li>\(  \to N-m \leq k \)</li>
</ul>
</li>
<li>By our hypothesis, \( L[1...m] \) and \( L[m+1...N] \) can be sorted</li>
<li>By the proved correctness of <em>merge</em> above,
the merged \( L[1...m] \) and \( L[m+1...N] \) is also sorted,
so the proof is done</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#complexity-3" id="complexity-3">Complexity</a></h2>
<pre>
  ^    +------------------------------------------------------+   Merge
  |    |                           N                          |   Complexity
  |    +------------------------------------------------------+
  |                 |                              |
  |                 v                              v
  |    +------------------------+    +------------------------+
  |    |           N/2          |    |           N/2          |   2 * O(N/2)
  |    +------------------------+    +------------------------+
  |         |              |              |              |
            v              v              v              v
  K    +---------+    +---------+    +---------+    +---------+
       |   N/4   |    |   N/4   |    |   N/4   |    |   N/4   |   4 * O(N/4)
  |    +---------+    +---------+    +---------+    +---------+
  |      |     |        |     |        |     |        |     |
  |      v     v        v     v        v     v        v     v
  |
  |                        .  .  .  .  .  .                       2^i * O(N/(2^i))
  |
  |    +---+  +---+  +---+                                +---+
  |    | 1 |  | 1 |  | 1 |  .  .  .  .  .  .  .  .  .  .  | 1 |   N * O(1)
  v    +---+  +---+  +---+                                +---+

  N: the number of list elements.
  K: K layers from N to 1.
     N/2^k = 1 => N = 2^K => K = log_2(N)
</pre>
<p>The above figure is the <strong>recursion tree</strong> of <em>merge sort</em>.
The list containing \( N \) elements is recursively divided to sort
until there is only one elements.
Suppose that there is \( K \) times of division, therefore,</p>
<p>\[
\begin{aligned}
\frac{ N }{ 2^K }   &amp;= 1 \newline
\to                 N &amp;= 2^K \newline
\to                 K &amp;= \log_{ 2 }N
\end{aligned}
\]</p>
<p>On the other hand, the time complexity
depends on the performance of <em>merge</em> \( T_{merge}(N) \).
The used <em>merge</em> here is the basic version.
It iteratively picks the minimal elements from both sublists
then copied to another list \( L^\prime \).
After all the elements in one sublist are all selected,
we move the rest elements in the other sublist to list \( L^\prime \).
Finally, we assigned \( L[i] \leftarrow L^\prime[i] \), \( \forall i \in [1, N] \).
Thus, \( T_{merge}(N) \) can be defined as</p>
<p>\[
T_{merge}(N) = c \cdot N
\]</p>
<p>where \( c \) is a constant reflecting the basic operations
like comparisons or assignments for merging routine.</p>
<h3><a class="header" href="#by-the-recursion-tree" id="by-the-recursion-tree">By the recursion tree</a></h3>
<p>From the above figure, the total time for the <em>merge sort</em> is</p>
<p>\[
\begin{aligned}
Time &amp;= 2 \cdot c \cdot \frac{N}{2} +4 \cdot c \cdot \frac{N}{4} + 8 \cdot c \cdot \frac{N}{8} + ... + N \cdot c \cdot 1 \newline
&amp;= K \cdot ( c \cdot N)
\end{aligned}
\]
, where \( K \) is the number of terms in the above equation.</p>
<p>The term is \( 2^K \cdot c \cdot \frac{N}{2^K} \) 
and it is from \( 2 \cdot c \cdot \frac{N}{2} \) to \( N \cdot c \cdot 1 \),
so we have \( K = \log_{ 2 }N \) terms.
As a result,</p>
<p>\[
Time = c \cdot N \cdot \log_{ 2 }N
\]</p>
<p>Thus, the time complexity is \( \mathcal{O}(N \log N) \).</p>
<h3><a class="header" href="#by-telescoping" id="by-telescoping">By telescoping</a></h3>
<p>Formally, since the <em>merge sort</em> repeatedly breaks down the \( N \)-elements list
into two \( \frac{N}{2} \)-elements sublists,
the amount of time that <em>merge sort</em>, \( T_{sort}(N) \),
can be written as follows:</p>
<p>\[
\begin{aligned}
T_{sort}(N)
&amp;= T_{sort}(\frac{N}{2}) + T_{sort}(\frac{N}{2}) + T_{merge}(N) \newline
&amp;= 2 \cdot T_{sort}(\frac{N}{2}) + T_{merge}(N) \newline
&amp;= 2 \cdot T_{sort}(\frac{N}{2}) + c \cdot N
\end{aligned}
\]</p>
<p>\[
\begin{aligned}
T_{sort}(N)
&amp;= 2 \cdot T_{sort}(\frac{N}{2}) + c \cdot N \newline
&amp;= 2 \cdot (2 \cdot T_{sort}(\frac{N}{4}) + c \cdot \frac{N}{2}) + c \cdot N \newline
&amp;= 2^2 \cdot T_{sort}(\frac{N}{4}) + 2 \cdot c \cdot N \newline
&amp;= 2^2 \cdot (2 \cdot T_{sort}(\frac{N}{8}) + c \cdot \frac{N}{4}) + 2 \cdot c \cdot N \newline
&amp;= 2^3 \cdot T_{sort}(\frac{N}{4}) + 3 \cdot c \cdot N \newline
&amp;= ... \newline
&amp;= 2^K \cdot T_{sort}(\frac{N}{2^K}) + K \cdot c \cdot N \newline
&amp;= N \cdot T_{sort}(1) + K \cdot c \cdot N \newline
&amp;= N \cdot 1 + K \cdot c \cdot N \newline
&amp;= N + c \cdot N \cdot \log_{ 2 }N
\end{aligned}
\]</p>
<p>Thus, the time complexity is \( \mathcal{O}(N \log N) \).</p>
<h2><a class="header" href="#implementation-3" id="implementation-3">Implementation</a></h2>
<script src="https://gist.github.com/ChunMinChang/dee9f3bd2ceab69726373ae006016edb.js?file=merge_sort.cpp"></script>
<h2><a class="header" href="#appendix" id="appendix">Appendix</a></h2>
<ul>
<li><a href="sorting/naive_inplace_merge.html">Naive in-pace merge</a></li>
</ul>
<!-- - [In-pace merge sort with working area][wimsort] -->
<h2><a class="header" href="#reference" id="reference">Reference</a></h2>
<ul>
<li><a href="http://www-bcf.usc.edu/%7Edkempe/CS104/11-07.pdf" title="2013 CS104: Recursive Sorting Algorithms and their Analysis">CS104</a></li>
<li><a href="http://www.cs.princeton.edu/courses/archive/spr07/cos226/lectures/04MergeQuick.pdf" title="Mergesort and Quicksort">COS226</a></li>
<li><a href="http://www.cs.mcgill.ca/%7Edprecup/courses/IntroCS/Lectures/comp250-lecture16.pdf" title="Lecture 16: MergeSort proof of correctness, and running time">COMP250</a></li>
<li><a href="http://www.inf.unibz.it/%7Enutt/DSA1112/DSALabs/sols2.pdf" title="Data Structures and Algorithms">DSA1112</a></li>
<li><a href="https://www.cs.rochester.edu/%7Egildea/csc282/slides/C02-start.pdf" title="Getting Started">CSC282</a></li>
</ul>
<h1><a class="header" href="#naive-in-place-merge" id="naive-in-place-merge">Naive in-place merge</a></h1>
<h2><a class="header" href="#correctness" id="correctness">Correctness</a></h2>
<p>\[
\begin{aligned}
&amp; naiveInplaceMerge(L, l, m, r): \newline
&amp; \space \space \space \space \text{for } i \leftarrow m+1 \text{ to } r: \newline
&amp; \space \space \space \space \space \space \space \space \text{for } j \leftarrow i \text{ down to } l+1: \newline
&amp; \space \space \space \space \space \space \space \space \space \space \space \space \text{if } L[j-1] \leq L[j]: \newline
&amp; \space \space \space \space \space \space \space \space \space \space \space \space \space \space \space \space \text{break} \newline
&amp; \space \space \space \space \space \space \space \space \space \space \space \space \text{swap } L[j-1] \text{ and } L[j]
\end{aligned}
\]</p>
<h3><a class="header" href="#lemma-1-1" id="lemma-1-1">Lemma 1</a></h3>
<blockquote>
<p>Given a sorted list \( A = [a_1, a_2, ..., a_N] \) with \( N \) elements,
where \( a_1 \leq a_2 \leq ... \leq a_N \),
and one value \( x \),
the list \( L = A \cup [x] = [a_1, a_2, ..., a_N, x] \)
(\( x \) is appended to the end of list \( A \)),
can be sorted by the <em>naive in-place merge</em> method with \( l = 1, m = N, r = N + 1 \).</p>
</blockquote>
<ul>
<li>Base step: When \( N = 0 \), list \( L = [x] \) is trivially true</li>
<li>Induction Hypothesis: Suppose this assumption holds when \( N = k \)</li>
<li>Induction Step: When \( N = k + 1 \)
<ul>
<li>If \( x \geq L[k] \), then the \( L = a_1 \leq a_2 \leq ... \leq a_k \leq x \) is naturally sorted</li>
<li>Otherwise, \( x &lt; L[k] \) and the \( x \) and \( L[k] \) are swapped.
<ul>
<li>Now \( L[1...k] = [a_1, a_2, ... , a_{k-1}, x] \)</li>
<li>By the hypothesis, the <em>naive in-place merge</em> works when \( N = k \), so we can a sorted \( L[1...k] \)</li>
<li>Thus, the list \( L \) now is sorted since \( L[1...k] \) is sorted
and all its elements are smaller than the current \( (k+1) \)th element \( L[k] \)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#lemma-2-1" id="lemma-2-1">Lemma 2</a></h3>
<blockquote>
<p>Given a sorted list \( A = [a_1, a_2, ..., a_N] \) with \( N \) elements
where \( a_1 \leq a_2 \leq ... \leq a_N \),
and \( B = [b_1, b_2, ..., b_M] \) with \( M \) elements
where \( b_1 \leq b_2 \leq ... \leq b_M \),
the list \( L = A \cup B = [a_1, a_2, ..., a_N, b_1, b_2, ..., b_M] \)
can be sorted by the above <em>naive in-place merge</em> method with \( l = 1, m = N, r = M+N \).</p>
</blockquote>
<ul>
<li>Base step: When \( M = 1 \), the condition is same as <em>Lemma 1</em>, so it's true</li>
<li>Induction Hypothesis: Suppose this assumption holds when \( M = k \)</li>
<li>Induction Step: When \( M = k + 1 \)
<ul>
<li>When \( i = N + 1 \)
<ul>
<li>the element \( L[N+1] \) will be merged with \( L[1...N] = A \)</li>
<li>then the list \( L[1...N+1] \) is sorted by <em>Lemma 1</em></li>
</ul>
</li>
<li>When \( i = N + 2 \)
<ul>
<li>the list is composed by sorted sublists \( A^\prime = L[1...N+1] \)
and \( B^\prime = L[N+2...N+k+1] \) with \( k \) elements</li>
<li>By the hypothesis, the <em>naive in-place merge</em> works when \( \vert B^\prime \vert = k \)</li>
<li>Thus, the list \( L = A^\prime \cup B^\prime = A \cup B \) is sorted</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#complexity-4" id="complexity-4">Complexity</a></h3>
<p>\( \mathcal{O}(N^2) \)</p>
<h1><a class="header" href="#quick-sort" id="quick-sort">Quick sort</a></h1>
<h2><a class="header" href="#implementation-4" id="implementation-4">Implementation</a></h2>
<script src="https://gist.github.com/ChunMinChang/dee9f3bd2ceab69726373ae006016edb.js?file=quick_sort.cpp"></script>
<h1><a class="header" href="#heap-sort" id="heap-sort">Heap sort</a></h1>
<h2><a class="header" href="#implementation-5" id="implementation-5">Implementation</a></h2>
<script src="https://gist.github.com/ChunMinChang/dee9f3bd2ceab69726373ae006016edb.js?file=heap_sort.cpp"></script>
<h1><a class="header" href="#graph" id="graph">Graph</a></h1>
<h1><a class="header" href="#shortest-path" id="shortest-path">Shortest path</a></h1>
<h1><a class="header" href="#floydwarshall" id="floydwarshall">Floydâ€“Warshall</a></h1>
<h2><a class="header" href="#implementation-6" id="implementation-6">Implementation</a></h2>
<script src="https://gist.github.com/ChunMinChang/3bf18068195534a0acc45851fd718791.js?file=FloydWarshall.cpp"></script><h1><a class="header" href="#dijkstra" id="dijkstra">Dijkstra</a></h1>
<p>In this article, the <em>Dijkstra</em> will be proved by <em>mathematical induction</em>.
Suppose we have following variables:</p>
<ul>
<li>\( G \) is the input graph</li>
<li>\( V \) is the set of all vertices</li>
<li>\( K \) is the set containing all visited vertices</li>
<li>\( s \) is source vertex</li>
<li>\( l(x, y) \) is the length of an edge from  \( x \) to  \( y \)</li>
<li>\( d(x) \) is shortest path distance found by <em>Dijkstra</em> algorithm.</li>
</ul>
<h2><a class="header" href="#dijkstra-algorithm" id="dijkstra-algorithm">Dijkstra algorithm</a></h2>
<p>\[
\begin{align}
&amp; \text{Dijkstra(\( G, s \)):} \newline
&amp; \space \space \space \space \text{for all \( u \in V \space \backslash \space \{ s \} \):} \newline
&amp; \space \space \space \space \space \space \space \space d(u) = \infty \newline
&amp; \space \space \space \space d(s) = 0 \newline
&amp; \space \space \space \space K = \{ \} \newline
&amp; \space \space \space \space \text{while \( K \neq V \):} \newline
&amp; \space \space \space \space \space \space \space \space\text{pick \( u \in V - K \) with smallest \( d(u) \)} \newline
&amp; \space \space \space \space \space \space \space \space K = K \cup \{ u \} \newline
&amp; \space \space \space \space \space \space \space \space \text{for all vertices \( v \) adjacent to \( u \):} \newline
&amp; \space \space \space \space \space \space \space \space \space \space \space \space \text{if \( d(v) &gt; d(u) + l(u, v) \) :} \newline
&amp; \space \space \space \space \space \space \space \space \space \space \space \space \space \space \space \space d(v) = d(u) + l(u, v)
\end{align}
\]</p>
<h2><a class="header" href="#proof-by-mathematical-induction-2" id="proof-by-mathematical-induction-2">Proof by mathematical induction</a></h2>
<p><img src="graph/Dijkstra.png" alt="Dijkstra" /></p>
<p><em>Proof</em>:
For each \( x \in K, \space d(x) \) is the shortest path from \( s \) to  \( x \).</p>
<ol>
<li>Basis: when \( \vert K \vert = 1, \space K = { s } \), the \( d(s) = 0 \),
the assumption is correct.</li>
<li>Inductive hypothesis:
<ul>
<li>Suppose the condition is hold when \( \vert K \vert = k &gt; 1 \).</li>
<li>Let \( m \) be the latest vertex(the \( k \)th vertex)
added to \( K, \space K = { s, ..., m } \).</li>
</ul>
</li>
<li>Inductive step:
<ul>
<li>Let \( n \) is the next vertex(the \( (k+1) \)th vertex)
that will be added to \( K \) (Currently, \( n \notin K \)).</li>
<li>Let \( l(m, n) \) be the chosen edge, where \( d(n) = d(m) + l(m, n) \).
The path from \( s \) to  \( m \) plus \( l(m, n) \) denotes \( P \),
and \( Length(P) = d(n) \).</li>
<li>Consider another path \( \hat{P} \) from \( s \) to \( n \) via \( x \),
where \( x \ne m\).
We will show \( Length(\hat{P}) \ge Length(P) \).</li>
<li>Let \( edge(x, y) \) is the first edge in \( \hat{P} \) that leaves \( K \).
That is, \( x \in K \) but \( y \notin K \).
\( \hat{P} \) is one path from \( s \) to  \( x \) to \( y \) to \( n \).</li>
<li>Let \( \hat{p} \) be one subpath of \( \hat{P} \) from \( s \) to \( x \), so
\( Length(\hat{p}) \ge d(x) \)</li>
<li>\( Length(\hat{P}) \ge Length(\hat{p}) + l(x, y) \).
(\( Length(\hat{P}) = Length(\hat{p}) + l(x, y) \) when \( y = n \).
In this case, \( l(x, n) \) is not chosen,
so \( Length(\hat{P}) = Length(\hat{p}) + l(x, n) \ge d(m) + l(m, n) = Length(P) \)).</li>
<li>From above: \( Length(\hat{P}) \ge d(x) + l(x, y) \ge d(y) \)</li>
<li>For all vertices \( i \in V - K \) including \( y, n \),
the minimal \( d(i) \) happens when \( i = n \),
so \( d(y) \ge d(n) \). (That's why \( n \) is chosen instead of \( y \).)</li>
<li>Thus, \( Length(\hat{P}) \ge d(n) = Length(P) \).</li>
</ul>
</li>
</ol>
<h2><a class="header" href="#simple-implementation" id="simple-implementation">Simple implementation</a></h2>
<script src="https://gist.github.com/ChunMinChang/3bf18068195534a0acc45851fd718791.js?file=Dijkstra.cpp"></script>
<h3><a class="header" href="#implementation-with-priority-queueheap" id="implementation-with-priority-queueheap">Implementation with priority-queue(heap)</a></h3>
<script src="https://gist.github.com/ChunMinChang/e5d2c22038672d46b86ebab7c679d80b.js?file=Graph.h"></script>
<script src="https://gist.github.com/ChunMinChang/e5d2c22038672d46b86ebab7c679d80b.js?file=ShortestPath.h"></script>
<script src="https://gist.github.com/ChunMinChang/e5d2c22038672d46b86ebab7c679d80b.js?file=Dijkstra.h"></script>
<script src="https://gist.github.com/ChunMinChang/e5d2c22038672d46b86ebab7c679d80b.js?file=Dijkstra.cpp"></script>
<h2><a class="header" href="#references" id="references">References</a></h2>
<ul>
<li><a href="http://web.cs.ucdavis.edu/%7Eamenta/w10/dijkstra.pdf">Proof for Dijkstraâ€™s Algorithm</a></li>
<li><a href="https://web.engr.oregonstate.edu/%7Eglencora/wiki/uploads/dijkstra-proof.pdf">Dijkstraâ€™s algorithm: Correctness by induction</a></li>
<li><a href="https://www.cs.auckland.ac.nz/software/AlgAnim/dij-proof.html">Proof of Dijkstra's Algorithm</a></li>
<li><a href="https://chunminchang.gitbooks.io/cplusplus-learning-note/content/Appendix/Dijkstra.html">Proof of Dijkstra</a></li>
</ul>
<h1><a class="header" href="#bellman-ford-moore" id="bellman-ford-moore">Bellman-Ford-Moore</a></h1>
<h2><a class="header" href="#simple-implementation-1" id="simple-implementation-1">Simple implementation</a></h2>
<script src="https://gist.github.com/ChunMinChang/3bf18068195534a0acc45851fd718791.js?file=BellmanFordMoore.cpp"></script>
<h3><a class="header" href="#implementation-with-graph" id="implementation-with-graph">Implementation with graph</a></h3>
<script src="https://gist.github.com/ChunMinChang/e5d2c22038672d46b86ebab7c679d80b.js?file=Graph.h"></script>
<script src="https://gist.github.com/ChunMinChang/e5d2c22038672d46b86ebab7c679d80b.js?file=ShortestPath.h"></script>
<script src="https://gist.github.com/ChunMinChang/e5d2c22038672d46b86ebab7c679d80b.js?file=BFM.h"></script>
<script src="https://gist.github.com/ChunMinChang/e5d2c22038672d46b86ebab7c679d80b.js?file=BFM.cpp"></script>
<h1><a class="header" href="#shortest-path-faster-algorithm" id="shortest-path-faster-algorithm">Shortest Path Faster Algorithm</a></h1>
<h2><a class="header" href="#implementation-7" id="implementation-7">Implementation</a></h2>
<script src="https://gist.github.com/ChunMinChang/e5d2c22038672d46b86ebab7c679d80b.js?file=Graph.h"></script>
<script src="https://gist.github.com/ChunMinChang/e5d2c22038672d46b86ebab7c679d80b.js?file=ShortestPath.h"></script>
<script src="https://gist.github.com/ChunMinChang/e5d2c22038672d46b86ebab7c679d80b.js?file=BFM.h"></script>
<script src="https://gist.github.com/ChunMinChang/e5d2c22038672d46b86ebab7c679d80b.js?file=BFM.cpp"></script>
<script src="https://gist.github.com/ChunMinChang/e5d2c22038672d46b86ebab7c679d80b.js?file=SPFA.h"></script>
<script src="https://gist.github.com/ChunMinChang/e5d2c22038672d46b86ebab7c679d80b.js?file=SPFA.cpp"></script>
<h1><a class="header" href="#minimal-spanning-tree" id="minimal-spanning-tree">Minimal spanning tree</a></h1>
<h1><a class="header" href="#kruskal" id="kruskal">Kruskal</a></h1>
<h2><a class="header" href="#implementation-8" id="implementation-8">Implementation</a></h2>
<h3><a class="header" href="#graph-1" id="graph-1">Graph</a></h3>
<script src="https://gist.github.com/ChunMinChang/81862ff828866aa095e2f3626370beaf.js?file=Graph.h"></script>
<h3><a class="header" href="#kruskal-1" id="kruskal-1">Kruskal</a></h3>
<script src="https://gist.github.com/ChunMinChang/81862ff828866aa095e2f3626370beaf.js?file=Kruskal.h"></script>
<script src="https://gist.github.com/ChunMinChang/81862ff828866aa095e2f3626370beaf.js?file=Kruskal.cpp"></script>
<h3><a class="header" href="#disjointset" id="disjointset">DisjointSet</a></h3>
<script src="https://gist.github.com/ChunMinChang/81862ff828866aa095e2f3626370beaf.js?file=DisjointSet.h"></script>
<h1><a class="header" href="#prim" id="prim">Prim</a></h1>
<h2><a class="header" href="#implementation-9" id="implementation-9">Implementation</a></h2>
<h3><a class="header" href="#graph-2" id="graph-2">Graph</a></h3>
<script src="https://gist.github.com/ChunMinChang/81862ff828866aa095e2f3626370beaf.js?file=Graph.h"></script>
<h3><a class="header" href="#prim-1" id="prim-1">Prim</a></h3>
<script src="https://gist.github.com/ChunMinChang/81862ff828866aa095e2f3626370beaf.js?file=Prim.h"></script>
<script src="https://gist.github.com/ChunMinChang/81862ff828866aa095e2f3626370beaf.js?file=Prim.cpp"></script>
<h1><a class="header" href="#search" id="search">Search</a></h1>
<h1><a class="header" href="#binary-search" id="binary-search">Binary search</a></h1>
<h2><a class="header" href="#implementation-10" id="implementation-10">Implementation</a></h2>
<script src="https://gist.github.com/ChunMinChang/ab8650e04f467a8b4f38da807a0d5797.js?file=binary_search.cpp"></script>
<h1><a class="header" href="#interpolation-search" id="interpolation-search">Interpolation search</a></h1>
<h2><a class="header" href="#implementation-11" id="implementation-11">Implementation</a></h2>
<script src="https://gist.github.com/ChunMinChang/ab8650e04f467a8b4f38da807a0d5797.js?file=interpolation_search.cpp"></script>
<h1><a class="header" href="#fibonacci-search" id="fibonacci-search">Fibonacci search</a></h1>
<h2><a class="header" href="#implementation-12" id="implementation-12">Implementation</a></h2>
<script src="https://gist.github.com/ChunMinChang/ab8650e04f467a8b4f38da807a0d5797.js?file=fibonacci_search.cpp"></script>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
        
        

    </body>
</html>
